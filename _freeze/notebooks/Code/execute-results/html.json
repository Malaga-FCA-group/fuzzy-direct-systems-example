{
  "hash": "02a7119f659b3be8ad499d3a5882d11c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Code and example\nauthor: Domingo López-Rodríguez, Manuel Ojeda-Hernández\n---\n\n\n\n\n# Introduction\n\nThis is the code and the example in the paper _On direct systems of implications with graded attributes_ submitted to EUSFLAT 2025.\n\n# Prerequisites\n\nWe assume knowledge of the `R` programming language. The libraries `digest`, `glue`, and `rlang` should be installed.\n\n# Code\n\n## Auxiliary functions\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\ntnorm <- \\(alpha, beta) max(c(0, alpha + beta - 1))\nunion <- \\(A, B) pmax(A, B)\nsetminus <- \\(A, B) {A[B >= A] <- 0; return(A)}\notimes <- \\(alpha, A) {sapply(A, \\(x) tnorm(alpha, x))}\n\nprint_implication <- function(A, B) {\n\n  print_set <- function(A) {\n\n    a <- A[A > 0]\n    v_str <- ifelse(a < 1,\n                    glue::glue(\" ({a})\"),\n                    \"\")\n\n    glue::glue(\"{names(a)}{v_str}\") |>\n      stringr::str_flatten_comma()\n\n  }\n\n  a <- print_set(A)\n  b <- print_set(B)\n  glue::glue(\"{a} -> {b}\")\n\n}\n\n# Helps in printing implications for easy reading\nprint_all_implications <- function(LHS, RHS) {\n\n  txt <- c()\n  for (i in seq_along(LHS)) {\n\n    txt <- c(txt, print_implication(LHS[[i]], RHS[[i]]))\n\n  }\n\n  return(txt)\n\n}\n```\n:::\n\n\n\n\n## `DirectSystem`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\ndirect_system <- function(SigmaLHS, SigmaRHS) {\n  \n  iter <- 0\n  \n  old_pairwise <- matrix(FALSE,\n                         nrow = length(SigmaLHS),\n                         ncol = length(SigmaRHS))\n  colnames(old_pairwise) <- rownames(old_pairwise) <- names(SigmaLHS)\n  \n  repeat {\n    \n    iter <- iter + 1\n    \n    new_pairwise <- matrix(FALSE,\n                           nrow = length(SigmaLHS),\n                           ncol = length(SigmaRHS))\n    colnames(new_pairwise) <- rownames(new_pairwise) <- names(SigmaLHS)\n    \n    new_pairwise[old_pairwise] <- TRUE\n    \n    added <- FALSE\n    \n    newLHS <- newRHS <- list()\n    \n    hashes <- names(SigmaLHS)\n    \n    configs <- expand.grid(hashes, hashes)\n    \n    for (idx in seq(nrow(configs))) {\n      \n      i <- configs[idx, 1]\n      j <- configs[idx, 2]\n      \n      if (i == j) next\n      if (new_pairwise[i, j]) next\n      \n      new_pairwise[i, j] <- TRUE\n      \n      A <- SigmaLHS[[i]]; B <- SigmaRHS[[i]]\n      C <- SigmaLHS[[j]]; D <- SigmaRHS[[j]]\n      \n      Derived <- add_derived(A, B, C, D)\n      \n      Derived <- combine(Derived[[1]], Derived[[2]],\n                         newLHS, newRHS)\n      newLHS <- Derived$lhs\n      newRHS <- Derived$rhs\n      \n    }\n    \n    # optional, simplification of D\n    # cat(\"*** Simplifying D:\\n\")\n    # AA <- simplify(newLHS, newRHS)\n    # newLHS <- AA[[1]]\n    # newRHS <- AA[[2]]\n    \n    # Combine:  \n    AA <- combine(newLHS, newRHS,\n                  SigmaLHS, SigmaRHS,\n                  new_pairwise)\n    \n    SigmaLHS <- AA$lhs\n    SigmaRHS <- AA$rhs\n    added <- AA$added\n    \n    old_pairwise <- AA$new_pairwise\n    if (!added) break\n    \n  }\n  \n  return(invisible(list(SigmaLHS, SigmaRHS)))\n  \n}\n```\n:::\n\n\n\n\n## `AddDerived`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nadd_derived <- function(A, B, C, D) {\n  \n  LHS <- RHS <- list()\n  \n  for (alpha in L) {\n    \n    if (alpha == 0) next\n    \n    alphaA <- otimes(alpha, A)\n    alphaB <- otimes(alpha, B)\n    \n    for (beta in L) {\n      \n      if (beta == 0) next\n      \n      cond1 <- setminus(otimes(beta, C), alphaB)\n      cond2 <- setminus(otimes(beta, D), alphaA)\n      \n      if ((sum(cond1) == 0) || (sum(cond2) == 0)) next\n      \n      G <- union(alphaA, cond1)\n      H <- cond2\n      \n      LHS <- append(LHS, list(G))\n      RHS <- append(RHS, list(H))\n      \n    }\n    \n  }\n  \n  return(list(LHS, RHS))\n  \n}\n```\n:::\n\n\n\n\n\n## `Combine`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\ncombine <- function(LHS1, RHS1,\n                    SigmaLHS, SigmaRHS,\n                    new_pairwise) {\n  \n  update <- TRUE\n  if (missing(new_pairwise)) update <- FALSE\n  \n  added <- FALSE\n  \n  for (i in seq_along(LHS1)) {\n    \n    hashA <- digest::digest(LHS1[[i]])\n    \n    if (is.null(SigmaLHS[[hashA]])) {\n      \n      added <- TRUE\n      SigmaLHS[[hashA]] <- LHS1[[i]]\n      SigmaRHS[[hashA]] <- RHS1[[i]]\n      \n    } else {\n      \n      # It is already an implication with that LHS\n      if (any(RHS1[[i]] > SigmaRHS[[hashA]])) {\n        \n        # New information\n        added <- TRUE\n        if (update) {\n          \n          new_pairwise[hashA, ] <- FALSE\n          new_pairwise[, hashA] <- FALSE\n          \n        }\n        SigmaRHS[[hashA]] <- union(SigmaRHS[[hashA]], RHS1[[i]])\n        \n      } else {\n        \n        # It was already considered in the system\n        \n      }\n      \n    }\n    \n  }\n  \n  if (update) {\n    \n    return(list(added = added,\n                lhs = SigmaLHS, rhs = SigmaRHS,\n                new_pairwise = new_pairwise))\n    \n  }\n  return(list(added = added,\n              lhs = SigmaLHS, rhs = SigmaRHS))\n  \n}\n```\n:::\n\n\n\n\n# Example\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# Example in the paper\nL <- c(0, 0.5, 1)\nLHS1 <- c(0.5, 0, 1, 0) |> rlang::set_names(letters[1:4])\nRHS1 <- c(0, 1, 0, 0.5) |> rlang::set_names(letters[1:4])\nLHS2 <- c(0.5, 1, 0, 0.5) |> rlang::set_names(letters[1:4])\nRHS2 <- c(1, 0, 1, 1) |> rlang::set_names(letters[1:4])\n\nLHS <- list(LHS1, LHS2)\nRHS <- list(RHS1, RHS2)\n```\n:::\n\n\n\n\n## Initialize $\\Sigma$\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nSigmaLHS <- SigmaRHS <- list()\nSigma <- combine(LHS, RHS, \n                 SigmaLHS, SigmaRHS)\nSigmaLHS <- Sigma$lhs\nSigmaRHS <- Sigma$rhs\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nprint_all_implications(SigmaLHS, SigmaRHS)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a (0.5), c -> b, d (0.5)\"       \"a (0.5), b, d (0.5) -> a, c, d\"\n```\n\n\n:::\n:::\n\n\n\n\n\n## Perform `DirectSystem`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nSigma_d_LR <- direct_system(SigmaLHS, SigmaRHS)\nSigma_dLHS <- Sigma_d_LR[[1]]\nSigma_dRHS <- Sigma_d_LR[[2]]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nprint_all_implications(Sigma_dLHS, Sigma_dRHS)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"a (0.5), c -> a, b, d\"                  \n [2] \"a (0.5), b, d (0.5) -> a, c, d\"         \n [3] \"b (0.5), c -> a, b, d\"                  \n [4] \"a (0.5), b, c (0.5), d (0.5) -> a, c, d\"\n [5] \"c (0.5) -> a (0.5), b (0.5), d (0.5)\"   \n [6] \"a (0.5), b (0.5), c -> a, b, d\"         \n [7] \"b, c (0.5) -> a, c, d\"                  \n [8] \"b (0.5) -> a (0.5), c (0.5), d (0.5)\"   \n [9] \"b -> a, c, d\"                           \n[10] \"c -> a, b, d\"                           \n```\n\n\n:::\n:::\n",
    "supporting": [
      "Code_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}